# Доказательство корректности алгоритма

## Доказательство корректности однопоточного кода:

### Корректность размера окна Window Rate Limiter

Обозначим размер окна, как - windowCapacity

Колличество запросов в окне изменяется только в момент поступления нового запроса. Причем перед добавлением запроса мы подсчитываем колличество запросов в диапозоне [текущее время - длительность окна, текущее время], чтобы не превышало.

Такой подход дает нам то, что в случае добавления нового запроса в этом окне, колличество запросов не будет превышать размер Окна. И каждый следующий пришедший запрос будет это поддерживать.

`Доказательство:`

Предположим, что все таки нашелся непрерывный промежуток по диапазону времени вложенный в длительность окна, такой что количество запросов в нем превышает размер окна. Рассмотрим подмножество этих запросов: с первого по размер окна + 1. Рассмотрим последний запрос, получается что в момент добавления этого запроса количество запросов в окне до него включая было минимум с размер окна, из чего делаем вывод добавить его по алгоритму мы не могли. А значит алгоритм корректен относительно размера окна.



### Корректность обработки запроса

Примечания:
1) Если во время обработки запроса алгоритм добпаляет его в окно, то также сохраняет в отдельный список
2) Перед добавлением запроса в окно, совершается проход по всем сохраненным запросам и подсчитывается количество в текущем окне

#### Если запрос должен добавиться, то алгоритм его добавит

`Доказательство:`

Предположим, что произошло так, что запрос должен был добавиться, в окно так, как было место, но этого не произошло. В момент обработки запроса мы предпосчитали количество запросов в текущем окне по времени из сохраненных. Так как запрос должен был бы добавиться, то это означает, что их меньше, чем размер окна. А условием добавления и есть проверка условия, что количество запросов в текущем окне не превышает размерности окна. Из чего следует, что не могло произойти ситуации, когда мы ошибочно не добавляем.

#### Если запрос не должен добавиться, то алгоритм его отклонить

Причиной отклонения запроса является то, что колличество запросов в текущем окне равно размерности окна.

`Доказательство:`

Предположим, что произошла ситуация, что алгоритм добавил запрос, который должен был отклонить. Так как перед принятием решения о добавлении или отклонении запроса мы предпосчитываем число запросов в окне, если их столько же, как размер окна, то алгоритм отклонит запрос(но мы предположиди обратное, не подходит). В альтернативном случае их количество было меньше, чем размерность окна. Значит в какой-то момент мы не добавили запрос, который должен был бы быть в этом окне. Но из доказательства выше следует невозможность данной ситуации. А значит мы добавили все запросы, которые должны быть в данном окне. И раз их меньше, чем размер окна, то запрос который мы предположили должен отклониться не является таковым.

## Доказательство корректности многопоточного кода:

### Отсуствие гонок

`Доказательство:`

У нас isHandled, countRequestNumber, getServedRequests, getRequestNumber - методы в которых мы берем локи/соверашем атомарные операции.

Метод countRequestNumber приватный метод и вызывается под локом в isHandled, поэтому можно свести до: isHandled, getServedRequests, getRequestNumber обощив.

В методах getServedRequests и getRequestNumber мы только обращаемся к переменным volotile и atomic по одной команде, причем на чтение и запись => гонка там остуствует.

Остается метод isHandled, но до взятия lock каждый поток объявляет себе две локальных переменных, а остальная часть кода однопоточна. Следовательно в реализации кода ThreadSafeSlidingWindowRateLimiter остуствует обращение к общим переменным в разных местах. (Исключение атомарной переменной и volotile листа, но там только операции на чтение/запись, которые атомарны).

### Отсуствие деадлоков

`Доказательство:`

Аналогично предыдущему выводу по обрасыванию методов получаем, что из isHandled, countRequestNumber, getServedRequests, getRequestNumber у нас могут быть вопросы только к isHandled.

Но в данном месте поле инициализации двух локальных переменных(каждые свои для отдельных потоков) идет код под локом. Тоесть деадлок может случиться только при условии того, что поток сам себя заблочит. Но мы берем лок только один раз, все остальное обращение к переменным, даже если это volatile или atomic, они берутся без условий на lock, а значит и поток его отпустит. Причем если в процессе выполнения получим ошибку при выполнении кода, то через исключение лок отпустится.

### Корректность алгоритма

`Доказательство:`

Весь алгоритм выполняется в методах isHandled и countRequestNumber, но так как мы показали вложенность для одного потока ранее, то можно обобщить и сказать, что вся обработка запроса происходит в методе isHandled. Причем если учесть, что кроме инициализации двух локальных переменных весь остальной код происходит в одном потоке, то можно сказать, что весь алгорит будет однопоточен.

А корректность однопоточного кода мы доказали выше.
